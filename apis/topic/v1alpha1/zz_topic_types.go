// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type TopicInitParameters struct {

	// (Boolean) Indicates whether the topic can be deleted.
	// Indicates whether the topic can be deleted.
	AllowDeletion *bool `json:"allowDeletion,omitempty" tf:"allow_deletion,omitempty"`

	// (String) The cluster API URL. Changing this will prevent deletion of the resource on the existing cluster. It is generally a better idea to delete an existing resource and create a new one than to change this value unless you are planning to do state imports
	// The cluster API URL. Changing this will prevent deletion of the resource on the existing cluster. It is generally a better idea to delete an existing resource and create a new one than to change this value unless you are planning to do state imports
	ClusterAPIURL *string `json:"clusterApiUrl,omitempty" tf:"cluster_api_url,omitempty"`

	// (Map of String) A map of string key/value pairs of topic configurations.
	// A map of string key/value pairs of topic configurations.
	// +mapType=granular
	Configuration map[string]*string `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// (Number) The number of partitions for the topic. This determines how the data is distributed across brokers. Increases are fully supported without data loss, decreases will result in an error and should be accomplished by creating a new topic and migrating the data.
	// The number of partitions for the topic. This determines how the data is distributed across brokers. Increases are fully supported without data loss, decreases will result in an error and should be accomplished by creating a new topic and migrating the data.
	PartitionCount *float64 `json:"partitionCount,omitempty" tf:"partition_count,omitempty"`

	// (Number) The replication factor for the topic, which defines how many copies of the data are kept across different brokers for fault tolerance.
	// The replication factor for the topic, which defines how many copies of the data are kept across different brokers for fault tolerance.
	ReplicationFactor *float64 `json:"replicationFactor,omitempty" tf:"replication_factor,omitempty"`
}

type TopicObservation struct {

	// (Boolean) Indicates whether the topic can be deleted.
	// Indicates whether the topic can be deleted.
	AllowDeletion *bool `json:"allowDeletion,omitempty" tf:"allow_deletion,omitempty"`

	// (String) The cluster API URL. Changing this will prevent deletion of the resource on the existing cluster. It is generally a better idea to delete an existing resource and create a new one than to change this value unless you are planning to do state imports
	// The cluster API URL. Changing this will prevent deletion of the resource on the existing cluster. It is generally a better idea to delete an existing resource and create a new one than to change this value unless you are planning to do state imports
	ClusterAPIURL *string `json:"clusterApiUrl,omitempty" tf:"cluster_api_url,omitempty"`

	// (Map of String) A map of string key/value pairs of topic configurations.
	// A map of string key/value pairs of topic configurations.
	// +mapType=granular
	Configuration map[string]*string `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// (String) The ID of this resource.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Number) The number of partitions for the topic. This determines how the data is distributed across brokers. Increases are fully supported without data loss, decreases will result in an error and should be accomplished by creating a new topic and migrating the data.
	// The number of partitions for the topic. This determines how the data is distributed across brokers. Increases are fully supported without data loss, decreases will result in an error and should be accomplished by creating a new topic and migrating the data.
	PartitionCount *float64 `json:"partitionCount,omitempty" tf:"partition_count,omitempty"`

	// (Number) The replication factor for the topic, which defines how many copies of the data are kept across different brokers for fault tolerance.
	// The replication factor for the topic, which defines how many copies of the data are kept across different brokers for fault tolerance.
	ReplicationFactor *float64 `json:"replicationFactor,omitempty" tf:"replication_factor,omitempty"`
}

type TopicParameters struct {

	// (Boolean) Indicates whether the topic can be deleted.
	// Indicates whether the topic can be deleted.
	// +kubebuilder:validation:Optional
	AllowDeletion *bool `json:"allowDeletion,omitempty" tf:"allow_deletion,omitempty"`

	// (String) The cluster API URL. Changing this will prevent deletion of the resource on the existing cluster. It is generally a better idea to delete an existing resource and create a new one than to change this value unless you are planning to do state imports
	// The cluster API URL. Changing this will prevent deletion of the resource on the existing cluster. It is generally a better idea to delete an existing resource and create a new one than to change this value unless you are planning to do state imports
	// +kubebuilder:validation:Optional
	ClusterAPIURL *string `json:"clusterApiUrl,omitempty" tf:"cluster_api_url,omitempty"`

	// (Map of String) A map of string key/value pairs of topic configurations.
	// A map of string key/value pairs of topic configurations.
	// +kubebuilder:validation:Optional
	// +mapType=granular
	Configuration map[string]*string `json:"configuration,omitempty" tf:"configuration,omitempty"`

	// (Number) The number of partitions for the topic. This determines how the data is distributed across brokers. Increases are fully supported without data loss, decreases will result in an error and should be accomplished by creating a new topic and migrating the data.
	// The number of partitions for the topic. This determines how the data is distributed across brokers. Increases are fully supported without data loss, decreases will result in an error and should be accomplished by creating a new topic and migrating the data.
	// +kubebuilder:validation:Optional
	PartitionCount *float64 `json:"partitionCount,omitempty" tf:"partition_count,omitempty"`

	// (Number) The replication factor for the topic, which defines how many copies of the data are kept across different brokers for fault tolerance.
	// The replication factor for the topic, which defines how many copies of the data are kept across different brokers for fault tolerance.
	// +kubebuilder:validation:Optional
	ReplicationFactor *float64 `json:"replicationFactor,omitempty" tf:"replication_factor,omitempty"`
}

// TopicSpec defines the desired state of Topic
type TopicSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     TopicParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider TopicInitParameters `json:"initProvider,omitempty"`
}

// TopicStatus defines the observed state of Topic.
type TopicStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        TopicObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// Topic is the Schema for the Topics API. Topic represents a Kafka topic configuration
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,redpanda}
type Topic struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.clusterApiUrl) || (has(self.initProvider) && has(self.initProvider.clusterApiUrl))",message="spec.forProvider.clusterApiUrl is a required parameter"
	Spec   TopicSpec   `json:"spec"`
	Status TopicStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// TopicList contains a list of Topics
type TopicList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Topic `json:"items"`
}

// Repository type metadata.
var (
	Topic_Kind             = "Topic"
	Topic_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Topic_Kind}.String()
	Topic_KindAPIVersion   = Topic_Kind + "." + CRDGroupVersion.String()
	Topic_GroupVersionKind = CRDGroupVersion.WithKind(Topic_Kind)
)

func init() {
	SchemeBuilder.Register(&Topic{}, &TopicList{})
}
